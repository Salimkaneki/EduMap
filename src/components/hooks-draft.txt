// hooks/useMapIcons.ts
import { useCallback } from 'react';
import L from 'leaflet';
import type { Establishment } from '@/types/types';

interface ExtendedIconDefaultPrototype extends L.Icon.Default {
  _getIconUrl?: string;
}

export const useMapIcons = () => {
  // Fonction pour fixer le problème des icônes Leaflet dans Next.js
  const fixLeafletIcon = useCallback(() => {
    if (typeof window !== 'undefined') {
      delete ((L.Icon.Default.prototype as ExtendedIconDefaultPrototype)._getIconUrl);
      L.Icon.Default.mergeOptions({
        iconRetinaUrl: '/leaflet/marker-icon-2x.png',
        iconUrl: '/leaflet/marker-icon.png',
        shadowUrl: '/leaflet/marker-shadow.png',
      });
    }
  }, []);

  // Fonction pour créer des icônes personnalisées basées sur les infrastructures
  const createCustomIcon = useCallback((establishment: Establishment) => {
    const hasElectricity = establishment.existe_elect === 'OUI';
    const hasLatrine = establishment.existe_latrine === 'OUI';
    const hasWater = establishment.eau === 'OUI';
    const hasAllSeasonAccess = establishment.acces_toute_saison === 'OUI';
    
    let iconColor = 'blue'; // Par défaut
    
    // Déterminer la couleur en fonction des infrastructures disponibles
    if (hasElectricity && hasLatrine && hasWater && hasAllSeasonAccess) {
      iconColor = 'green'; // Toutes les infrastructures
    } else if (hasElectricity && hasWater) {
      iconColor = 'orange'; // Infrastructures de base
    } else if (!hasElectricity && !hasWater) {
      iconColor = 'red'; // Infrastructures limitées
    }
    
    return L.divIcon({
      className: 'custom-marker',
      html: `<div style="background-color:${iconColor}; width:10px; height:10px; border-radius:50%; border:2px solid white;"></div>`,
      iconSize: [15, 15],
      iconAnchor: [7, 7]
    });
  }, []);

  return {
    fixLeafletIcon,
    createCustomIcon
  };
};

// hooks/useFilteredEstablishments.ts
import { useMemo } from 'react';
import type { Establishment } from '@/types/types';

interface FilterOptions {
  withElectricity?: boolean;
  withWater?: boolean;
  withLatrine?: boolean;
  allSeasonAccess?: boolean;
  type?: string;
  region?: string;
}

export const useFilteredEstablishments = (establishments: Establishment[], filters: FilterOptions) => {
  // Filtre les établissements en fonction des critères
  const filteredEstablishments = useMemo(() => {
    return establishments.filter(establishment => {
      if (filters.withElectricity && establishment.existe_elect !== 'OUI') return false;
      if (filters.withWater && establishment.eau !== 'OUI') return false;
      if (filters.withLatrine && establishment.existe_latrine !== 'OUI') return false;
      if (filters.allSeasonAccess && establishment.acces_toute_saison !== 'OUI') return false;
      if (filters.type && establishment.libelle_type_statut_etab !== filters.type) return false;
      if (filters.region && establishment.region !== filters.region) return false;
      return true;
    });
  }, [establishments, filters]);

  // Calcule les statistiques des établissements filtrés
  const stats = useMemo(() => {
    const total = filteredEstablishments.length;
    const withElectricity = filteredEstablishments.filter(e => e.existe_elect === 'OUI').length;
    const withWater = filteredEstablishments.filter(e => e.eau === 'OUI').length;
    const withLatrine = filteredEstablishments.filter(e => e.existe_latrine === 'OUI').length;
    const withAllSeasonAccess = filteredEstablishments.filter(e => e.acces_toute_saison === 'OUI').length;

    return {
      total,
      withElectricity,
      withWater,
      withLatrine,
      withAllSeasonAccess
    };
  }, [filteredEstablishments]);

  return {
    filteredEstablishments,
    stats
  };
};

// hooks/useMapCluster.ts
import { useCallback, useEffect, useRef } from 'react';
import L from 'leaflet';
import 'leaflet.markercluster';
import type { Establishment } from '@/types/types';

export const useMapCluster = (establishments: Establishment[], map: L.Map | null) => {
  const clusterGroupRef = useRef<L.MarkerClusterGroup | null>(null);
  
  // Fonction pour créer un groupe de clusters
  const createClusterGroup = useCallback(() => {
    if (typeof window === 'undefined' || !map) return null;
    
    try {
      // Si la bibliothèque leaflet.markercluster est correctement chargée
      const clusterGroup = L.markerClusterGroup({
        chunkedLoading: true,
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true,
        maxClusterRadius: 40,
        iconCreateFunction: (cluster) => {
          const count = cluster.getChildCount();
          let size = 'small';
          
          if (count > 50) {
            size = 'large';
          } else if (count > 10) {
            size = 'medium';
          }
          
          return L.divIcon({
            html: `<div class="cluster-icon cluster-${size}">${count}</div>`,
            className: `marker-cluster marker-cluster-${size}`,
            iconSize: L.point(40, 40)
          });
        }
      });
      
      clusterGroupRef.current = clusterGroup;
      return clusterGroup;
    } catch (error) {
      console.error('Error creating cluster group:', error);
      // Fallback: Si la bibliothèque de clustering n'est pas disponible, retourner null
      return null;
    }
  }, [map]);
  
  // Fonction pour ajouter des marqueurs au groupe de clusters
  const addMarkersToCluster = useCallback((markers: L.Marker[]) => {
    if (!clusterGroupRef.current) return;
    
    clusterGroupRef.current.clearLayers();
    clusterGroupRef.current.addLayers(markers);
  }, []);
  
  // Nettoyer les clusters lors du démontage du composant
  useEffect(() => {
    return () => {
      if (clusterGroupRef.current && map) {
        map.removeLayer(clusterGroupRef.current);
      }
    };
  }, [map]);
  
  // Fonction pour rendre les clusters visibles/invisibles
  const toggleClusterVisibility = useCallback((visible: boolean) => {
    if (!clusterGroupRef.current || !map) return;
    
    if (visible) {
      if (!map.hasLayer(clusterGroupRef.current)) {
        map.addLayer(clusterGroupRef.current);
      }
    } else {
      if (map.hasLayer(clusterGroupRef.current)) {
        map.removeLayer(clusterGroupRef.current);
      }
    }
  }, [map]);
  
  return {
    createClusterGroup,
    addMarkersToCluster,
    toggleClusterVisibility,
    clusterGroup: clusterGroupRef.current
  };
};